/// autogenerated by protoc-plugin-js
import assert from 'nanoassert'
import { enumerable } from 'protobuf-codec/encode/types'
import { enumerable as decodeEnumerable } from 'protobuf-codec/decode/types'

export const INTERVAL_UNSPECIFIED = 0
export const INTERVAL_BLOCK = -1
export const INTERVAL_I1M = 60
export const INTERVAL_I5M = 300
export const INTERVAL_I15M = 900
export const INTERVAL_I1H = 3600
export const INTERVAL_I6H = 21600
export const INTERVAL_I1D = 86400

const enumValues = new Map([
  [0, 'INTERVAL_UNSPECIFIED'],
  [-1, 'INTERVAL_BLOCK'],
  [60, 'INTERVAL_I1M'],
  [300, 'INTERVAL_I5M'],
  [900, 'INTERVAL_I15M'],
  [3600, 'INTERVAL_I1H'],
  [21600, 'INTERVAL_I6H'],
  [86400, 'INTERVAL_I1D']
])
const enumNames = new Map([
  ['INTERVAL_UNSPECIFIED', 0],
  ['INTERVAL_BLOCK', -1],
  ['INTERVAL_I1M', 60],
  ['INTERVAL_I5M', 300],
  ['INTERVAL_I15M', 900],
  ['INTERVAL_I1H', 3600],
  ['INTERVAL_I6H', 21600],
  ['INTERVAL_I1D', 86400]
])

export function encode(value, buf, byteOffset = 0) {
  if (typeof value === 'string') return encode(parse(value), buf, byteOffset)
  if (value == null) throw new Error('Invalid Interval value (' + value + ')')

  return enumerable.encode(value, buf, byteOffset)
}

export function decode(varint) {
  const int = decodeEnumerable(varint)

  return stringify(int) ?? int
}

export function encodingLength(value) {
  if (typeof value === 'string') return encodingLength(parse(value))
  assert(value != null, 'Invalid Interval value (' + value + ')')

  // This enum may fully consume the max allowed size
  return 5
}

/**
 * Convert an enum value to it's human readable name.
 * Returns undefined on an unknown value.
 */
export function stringify(int) {
  return enumValues.get(int)
}

/**
 * Convert an enum string names to it's machine integer value.
 * Returns undefined on an unknown name.
 */
export function parse(str) {
  return enumNames.get(str)
}
