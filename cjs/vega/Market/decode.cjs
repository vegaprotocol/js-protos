'use strict';

var reader = require('protobuf-codec/decode/reader');
var types = require('protobuf-codec/decode/types');
var decode$6 = require('../TradableInstrument/decode.cjs');
var decode$5 = require('../Fees/decode.cjs');
var decode$4 = require('../AuctionDuration/decode.cjs');
var decode$3 = require('../PriceMonitoringSettings/decode.cjs');
var decode$2 = require('../LiquidityMonitoringParameters/decode.cjs');
var TradingMode = require('./TradingMode.cjs');
var State = require('./State.cjs');
var decode$1 = require('../MarketTimestamps/decode.cjs');

/// autogenerated by protoc-plugin-js

function decode(buf, byteOffset = 0, byteLength = buf.byteLength) {
  let field$id = '';
  let field$tradableInstrument = {};
  let field$decimalPlaces = 0n;
  let field$fees = {};
  let field$openingAuction = {};
  let field$priceMonitoringSettings = {};
  let field$liquidityMonitoringParameters = {};
  let field$tradingMode = 0;
  let field$state = 0;
  let field$marketTimestamps = {};
  let field$positionDecimalPlaces = 0n;
  let field$lpPriceRange = '';
  let field$linearSlippageFactor = '';
  let field$quadraticSlippageFactor = '';
  let field$parentMarketId = null;
  let field$insurancePoolFraction = null;
  let field$successorMarketId = null;
  for (const [field, { data }] of reader(buf, byteOffset, byteLength)) {
    switch (field) {
      case 1:
        field$id = types.string(data);
        break

      case 2:
        field$tradableInstrument = decode$6.decode(data);
        break

      case 3:
        field$decimalPlaces = types.uint64(data);
        break

      case 4:
        field$fees = decode$5.decode(data);
        break

      case 5:
        field$openingAuction = decode$4.decode(data);
        break

      case 6:
        field$priceMonitoringSettings =
          decode$3.decode(data);
        break

      case 7:
        field$liquidityMonitoringParameters =
          decode$2.decode(data);
        break

      case 8:
        field$tradingMode = TradingMode.decode(data);
        break

      case 9:
        field$state = State.decode(data);
        break

      case 10:
        field$marketTimestamps = decode$1.decode(data);
        break

      case 11:
        field$positionDecimalPlaces = types.int64(data);
        break

      case 12:
        field$lpPriceRange = types.string(data);
        break

      case 13:
        field$linearSlippageFactor = types.string(data);
        break

      case 14:
        field$quadraticSlippageFactor = types.string(data);
        break

      case 15:
        field$parentMarketId = types.string(data);
        break

      case 16:
        field$insurancePoolFraction = types.string(data);
        break

      case 17:
        field$successorMarketId = types.string(data);
        break
    }
  }
  return {
    id: field$id,
    tradableInstrument: field$tradableInstrument,
    decimalPlaces: field$decimalPlaces,
    fees: field$fees,
    openingAuction: field$openingAuction,
    priceMonitoringSettings: field$priceMonitoringSettings,
    liquidityMonitoringParameters: field$liquidityMonitoringParameters,
    tradingMode: field$tradingMode,
    state: field$state,
    marketTimestamps: field$marketTimestamps,
    positionDecimalPlaces: field$positionDecimalPlaces,
    lpPriceRange: field$lpPriceRange,
    linearSlippageFactor: field$linearSlippageFactor,
    quadraticSlippageFactor: field$quadraticSlippageFactor,
    parentMarketId: field$parentMarketId,
    insurancePoolFraction: field$insurancePoolFraction,
    successorMarketId: field$successorMarketId
  }
}

exports.decode = decode;
